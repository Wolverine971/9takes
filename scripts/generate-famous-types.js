// scripts/generate-famous-types.js

import fs from 'fs/promises';
import { existsSync } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { createClient } from '@supabase/supabase-js';
import dotenv from 'dotenv';

// Load environment variables
dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const STATIC_DIR = path.join(__dirname, '..', 'static');

const SUPABASE_URL = process.env.PUBLIC_SUPABASE_URL;
const SUPABASE_ANON_KEY = process.env.PUBLIC_SUPABASE_PUBLISHABLE_KEY;

if (!SUPABASE_URL || !SUPABASE_ANON_KEY) {
	console.error('‚ùå Missing Supabase environment variables');
	process.exit(1);
}

const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

async function getFamousPeople() {
	const { data: personData, error: personDataError } = await supabase
		.from('blogs_famous_people')
		.select('person, enneagram, published, lastmod, persona_title')
		.order('person');

	if (personDataError) {
		console.error('‚ùå Error fetching famous people:', personDataError.message);
		process.exit(1);
	}

	return personData || [];
}

function checkImageExists(personName, enneagramType) {
	// Check for small thumbnail (s-{name}.webp) used in UI components
	const smallImagePath = path.join(
		STATIC_DIR,
		'types',
		`${enneagramType}s`,
		`s-${personName}.webp`
	);
	if (existsSync(smallImagePath)) {
		return true;
	}

	// Also check for regular image ({name}.webp) as fallback
	const regularImagePath = path.join(
		STATIC_DIR,
		'types',
		`${enneagramType}s`,
		`${personName}.webp`
	);
	return existsSync(regularImagePath);
}

function groupByEnneagramType(people) {
	const grouped = {
		1: [],
		2: [],
		3: [],
		4: [],
		5: [],
		6: [],
		7: [],
		8: [],
		9: []
	};

	for (const person of people) {
		const type = person.enneagram;
		if (type >= 1 && type <= 9) {
			const hasImage = checkImageExists(person.person, type);
			grouped[type].push({
				name: person.person,
				link: person.published === true,
				hasImage,
				lastmod: person.lastmod || null,
				personaTitle: person.persona_title || null
			});
		}
	}

	// Sort each group: prioritize those with images, then alphabetically by name
	for (const type of Object.keys(grouped)) {
		grouped[type].sort((a, b) => {
			// First sort by hasImage (true first)
			if (a.hasImage !== b.hasImage) {
				return a.hasImage ? -1 : 1;
			}
			// Then alphabetically
			return a.name.localeCompare(b.name);
		});
	}

	return grouped;
}

function escapeForSingleQuotes(str) {
	// Escape single quotes and backslashes
	return str.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
}

function generateTypeScriptContent(groupedPeople) {
	const lines = ['// src/lib/components/molecules/famousTypes.ts'];
	lines.push('// Auto-generated by scripts/generate-famous-types.js - do not edit manually');
	lines.push(
		'export const famousTypes: { [index: number]: { name: string; link: boolean; hasImage: boolean; lastmod: string | null; personaTitle: string | null }[] } = {'
	);

	for (let type = 1; type <= 9; type++) {
		const people = groupedPeople[type];
		lines.push(`\t${type}: [`);

		for (let i = 0; i < people.length; i++) {
			const person = people[i];
			const comma = i < people.length - 1 ? ',' : '';
			const escapedName = escapeForSingleQuotes(person.name);
			const lastmodValue = person.lastmod ? `'${person.lastmod}'` : 'null';
			const personaTitleValue = person.personaTitle
				? `'${escapeForSingleQuotes(person.personaTitle)}'`
				: 'null';
			lines.push(
				`\t\t{ name: '${escapedName}', link: ${person.link}, hasImage: ${person.hasImage}, lastmod: ${lastmodValue}, personaTitle: ${personaTitleValue} }${comma}`
			);
		}

		const typeComma = type < 9 ? ',' : '';
		lines.push(`\t]${typeComma}`);
	}

	lines.push('};');
	lines.push('');

	return lines.join('\n');
}

async function generateFamousTypes() {
	try {
		console.log('üöÄ Generating famousTypes.ts...');

		const people = await getFamousPeople();
		console.log(`üìä Found ${people.length} famous people in database`);

		const groupedPeople = groupByEnneagramType(people);

		// Log counts per type
		for (let type = 1; type <= 9; type++) {
			const total = groupedPeople[type].length;
			const published = groupedPeople[type].filter((p) => p.link).length;
			const withImages = groupedPeople[type].filter((p) => p.hasImage).length;
			console.log(
				`   Type ${type}: ${total} people (${published} published, ${withImages} with images)`
			);
		}

		const content = generateTypeScriptContent(groupedPeople);

		const outputPath = path.join(
			__dirname,
			'..',
			'src',
			'lib',
			'components',
			'molecules',
			'famousTypes.ts'
		);
		await fs.writeFile(outputPath, content, 'utf-8');

		console.log('‚úÖ famousTypes.ts generated successfully');

		// Verify
		const stats = await fs.stat(outputPath);
		console.log(`üìÑ File size: ${(stats.size / 1024).toFixed(2)} KB`);
	} catch (error) {
		console.error('‚ùå Error generating famousTypes.ts:', error);
		process.exit(1);
	}
}

// Run the script
generateFamousTypes();
